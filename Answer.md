#### Краткий ответ
1. **Для небольших проектов (до ~50 блоков)** разница во времени компиляции между различными подходами незначительна (доли секунды). В этом случае выбор метода может основываться на удобстве и личных предпочтениях.

2. **Для средних и крупных проектов (от 100 блоков и более)** использование пакета `catchfilebetweentags` приводит к заметному росту времени компиляции, особенно если фрагменты текста содержат многострочный контент (`modular_inner`), а не просто вызовы макросов (`\lipsum`). Это критично при итеративной сборке, когда `pdflatex` запускается многократно.

3. **Альтернативное решение** на основе `\@namedef` и `\@nameuse` демонстрирует производительность, сопоставимую с "плоским" (`flat_inner`) включением текста, и является более предсказуемым подходом. Оно хорошо подходит для задач, описанных в исходном вопросе.

#### Кратко про контекст измерений
 - **Базовая линия:** За точку отсчёта взят документ типа `flat_inner`, где весь текст и изображения включены напрямую в основной `.tex`-файл. Это позволяет измерить "накладные расходы модульности".

 - **Окружение:** Тестирование проводилось на Arch Linux с `pdflatex` из состава TeX Live 2024 (TeX 3.141592653-2.6-1.40.26).

 - **Методика замера времени:**
   
   - При помощи стандартной команды `time`;
   - При помощи пакета `l3benchmark`.

  Подробнее см. раздел ["Как измерять время"](ссылка) в полной заметке.

#### Типы сравниваемых документов

Были измерены 6 различных типов документов:

1. `flat` -- наиболее близкий аналог примера, указанного в вопросе, но без разделения на несколько `.tex` файлов.
2. `flat_inner` -- аналог `flat`, но текст включается напрямую, а не через `\lipsum`.
3. `modular` -- наиболее близкий аналог примера, указанного в вопросе.
4. `modular_inner` -- аналог `modular`, но текст включается напрямую, а не через `\lipsum`. (Больше всего похож на реальный случай использования из вопроса.)
5. `modular_inner_last` -- аналог `modular_inner`, но вызывается всегда самый последний тег из определённых в `des.tex` и `data.tex`.
6. `macrodef` -- решение через `\@namedef` и `\@nameuse`.

Подробнее см. раздел ["Что измерять"](ссылка).

#### Ключевые результаты наглядно  (графики для $N \le 200$)

![alt text](plots_200/en_2_mean_time_comparison.png) 
![alt text](plots_200/en_3_mean_benchmark_comparison.png)

![alt text](plots_200/en_4_difference_modular_inner_vs_flat_inner.png)


Результаты для $200 < N < 2000$ приведены в репозитории. Подробнее про построение и описание см. раздел ["Основные результаты"](ссылка).

#### Кратко про альтернативное решение

В файлах `des.tex` заключать фрагменты в `\@namedef{desDes<N>}`:
```tex
\@namedef{desDes1}{%
Text ...
...
}

\@namedef{desDes2}{%
Text ...
...
}
...
```
Аналогично в `data.tex`:
```tex
\@namedef{dataData1}{%
Data ...
...
}
...
```
А в основном документе `main.tex`:
```tex
\makeatletter
\newcommand{\merge}[4]{\par\textbf{#1}\par\fig{#2}\@nameuse{#3}\par\@nameuse{#4}\par}
\makeatother
...
\makeatletter
\input{des.tex}
\input{data.tex}
\makeatother
...
\merge{Block 1}{images/test-image-1.png}{desDes1}{dataData1}
\merge{Block 2}{images/test-image-2.png}{desDes2}{dataData2}
```
Это решение обеспечивает производительность, близкую к "плоскому" (`flat_inner`) включению текста.
![alt text](plots/en_4_difference_macrodef_vs_flat_inner.png)

Подробнее см. раздел ["Альтернативное решение"](ссылка).

**Примечание:** Ваш вопрос довольно объёмный и заслуживает скорее небольшой заметки, чем краткого ответа, поэтому я подробно описал ход своих рассуждений с возможными изменениями и экспериментами в своём репозитории на GitHub. Там же вы найдёте полную версию этой заметки, скрипты для воспроизведения результатов и дополнительные материалы. Поскольку мой уровень английского оставляет желать лучшего, в репозитории также доступен оригинал на русском языке. Если возникнут вопросы по методике, скриптам или потребуются дополнительные измерения -- обращайтесь в комментариях.